/**
 * Anche in questo caso, come nel requisito 2, si richiede l'utilizzo di MQTT, ma a differenza del caso precedente
 * dove era utilizzato per ricevere informazioni dall'ambiente e dalla console, in questo caso verrà usato per inviare le informazioni.
 * In particolare dovrà inviare informazioni relativi al clock time del robot, questo per far sì che l'utente possa rendersi
 * conto, in base allo stato del robot, se è possibile usarlo o meno.
 * 
 * Dall'analisi si deduce che questo è un vincoli da aggiungere alla base di conoscenza del qactor che si occupa di verificare che i 
 * vincoli siano rispettati: mindrobot (attore introdotto già nel requisito precedente).
 * La mindrobot sarà il componente (l'attore) che avrà il compito di interagire con il resouce model andando a leggere e a 
 * modificare le informazioni in esso salvate.
 * 
 * Per ottenere il clock time è stata creata una classe java apposita it.unibo.utils.customDate, che contiene un metodo
 * getHours che aggiorna la base di conoscenza con l'orario attuale.
 */
System robotRoomba
Event constraint   : constraint(CONSTRAINT, VALUE) // CONSTRAINT contiene il tipo di vincolo VALUE contiene il nuovo valore

Dispatch moveRobot : usercmd(CMD)
Dispatch execMoveRobot : usercmd(CMD)

pubSubServer "ws://localhost:1884" //virtual robot
//pubSubServer "ws://192.168.43.214:1884" //real robot

Context ctxVirtualRobot ip [ host="localhost" port=8032 ] 
Context ctxMindRobot ip [ host="localhost" port=8030 ]
Context ctxRealRobot ip [ host="localhost" port=8031]

QActor virtualrobotexecutor context ctxVirtualRobot -pubsub {
	Plan init normal [
		javaRun it.unibo.utils.clientTcp.initClientConn("localhost","8999");
		delay 1000;
		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }"); // necessario per non farlo andare contro il sonar appena parte
		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }"); // necessario per non farlo andare contro il sonar appena parte
		println("Robot ready")
	]
	switchTo waitForCmd            
		 
   	Plan waitForCmd[  ]  
  	transition stopAfter 3600000   	//1h 
 		whenMsg execMoveRobot -> execMove  	  
 	finally repeatPlan 
 	
 	Plan execMove resumeLastPlan [
 		printCurrentMessage;
 		onMsg execMoveRobot : usercmd( robotgui(h(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'alarm' }");
    	onMsg execMoveRobot : usercmd( robotgui(w(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'moveForward', 'arg': -1 }");
     	onMsg execMoveRobot : usercmd( robotgui(s(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'moveBackward', 'arg': -1 }");
   		onMsg execMoveRobot : usercmd( robotgui(a(X)) )    -> 
  			javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnLeft', 'arg': 800 }");
    	onMsg execMoveRobot : usercmd( robotgui(d(X)) )    -> 
   			javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }")
 	] 
}

QActor realrobotexecutor context ctxRealRobot -pubsub {
	Plan init normal [
		javaOp "customExecute(\"python3 executor.py d\")";
		delay 5000;
		javaOp "customExecute(\"python3 executor.py a\")";
		delay 1000;
		println("Robot ready!")
	]
	switchTo waitForCmd
	
	Plan waitForCmd[  ]  
  	transition stopAfter 3600000   	//1h 
 		whenMsg execMoveRobot -> execMove  	  
 	finally repeatPlan
 	
 	Plan execMove resumeLastPlan [
 		printCurrentMessage;
 		onMsg execMoveRobot : usercmd( robotgui(h(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py h\")";
    	onMsg execMoveRobot : usercmd( robotgui(w(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py w\")";
     	onMsg execMoveRobot : usercmd( robotgui(s(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py s\")";
   		onMsg execMoveRobot : usercmd( robotgui(a(X)) )    -> 
  			javaOp "customExecute(\"python3 executor.py a\")";
    	onMsg execMoveRobot : usercmd( robotgui(d(X)) )    -> 
   			javaOp "customExecute(\"python3 executor.py d\")"
 	] 
 	
}
QActor mindrobot context ctxMindRobot -pubsub -g cyan {
	Rules {
		eval( let, X, X ). // lower equal than implementation using worldTheory.pl in src-more/it/unibo/mindrobot/
		eval( let, X, V ):- eval( lt, X , V ) .
		eval( get, X, X ). // greater equal than implementation using worldTheory.pl in src-more/it/unibo/mindrobot/
		eval( get, X, V ):- eval( gt, X , V ) .
		maxTemperature(25).
		startTime(7).
		endTime(10).
		currentTemperature(12).
		currentTime(8).
		checkTemperature(cold):-
				maxTemperature(MAX), 
				currentTemperature(CURRENT), 
				eval(let, CURRENT, MAX), !.
		checkTemperature(hot):- 
				maxTemperature(MAX), 
				currentTemperature(CURRENT), 
				eval(gt, CURRENT, MAX), !.
		checkTime(X):- 
				startTime(START),
				endTime(END),
				currentTime(CURRENT),
				eval(get, CURRENT, START),
				eval(let, CURRENT, END).
		checkConstraints(X):-
			checkTemperature(cold),
			checkTime(X).
	}
	
	Plan init normal [
		println("Mind robot ready")
	]
	switchTo waitPlan
	
	Plan waitPlan[  ]
	transition stopAfter 3600000   	//1h 
 		whenEvent constraint -> handleEvent,
 		whenMsg moveRobot -> handleMsg
 	finally repeatPlan 
 	
 	Plan handleEvent resumeLastPlan [
 		printCurrentEvent;
 		onEvent constraint : constraint(temp, V) -> ReplaceRule currentTemperature(X) with currentTemperature(V);
 		[ !? checkTemperature(hot)  ]{
 			publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
 			publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) )	
 		}
 	]
 	
 	Plan handleMsg resumeLastPlan [
 		/* Ogni volta che si riceve un messaggio di movimento deve essere aggiornato il clock time
 		 * in modo tale da verificare se il movimento del robot è consentito o meno
 		 */
 		javaRun it.unibo.utils.customDate.getHours();
 		/* Pubblico un messaggio realativo al tempo:
 		 * Attenzione devo far capire che il messaggio è per la console*/
 		//publishMsg "unibo/qasys" for "console" -m constraint : constraint(tempo, currentTime(V));
 		printCurrentMessage;
 		onMsg moveRobot : usercmd( robotgui(w(X)) ) ->{
 			[ !? checkConstraints(X)   ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(w(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(w(low)) )
 				}		
 			else
 				 println("Too hot to work or out of time")
		};
		onMsg moveRobot : usercmd( robotgui(s(X)) ) ->{
 			[ !? checkConstraints(X)   ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(s(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(s(low)) )
 				}		
 			else
 				  println("Too hot to work or out of time")
		};
		onMsg moveRobot : usercmd( robotgui(a(X)) ) ->{
 			[ !? checkConstraints(X) ]{
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(a(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(a(low)) )	
 				}	
 			else
 				  println("Too hot to work or out of time")
		};
		onMsg moveRobot : usercmd( robotgui(d(X)) ) ->{
 			[ !? checkConstraints(X) ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(d(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(d(low)) )	
 				}
 			else
 				  println("Too hot to work or out of time")
		};
 		onMsg moveRobot : usercmd( robotgui(h(X)) ) -> {
 			[ !? checkConstraints(X) ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) )	
 				
 				}	
 			else 
 				 println("Too hot to work or out of time")
		}
 	]
}