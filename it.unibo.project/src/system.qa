/**
 * In fase di progettazione il requisito due richiede l'utilizzo di MQTT per ricevere le informazioni dall'ambiente 
 * e dalla console, richiede la creazione anche di un resource model del sistema che conterrà le informazioni sullo stato
 * del robot, dei vari "sensori" (per ora solo quello di temperatura che tra l'altro non è un sensore perchè otteniamo 
 * dall'esterno le info) il resource model sarà anche utile per eventuali sensori/attuatori futuri.
 * 
 * Questo resource model verrà realizzato mediante fatti e regole prolog (per quanto riguarda il robot) mentre sarà realizzato
 * in json e salvato in un database mongodb per quanto riguarda il server node
 * 
 * La mindrobot sarà il componente (l'attore) che avrà il compito di interagire con il resouce model andando a leggere e a 
 * modificare le informazioni in esso salvate.
 * 
 * TODO valutare dove mettere la mindrobot in fase di progettazione e quindi in fase di implementazione, perchè se sta nello 
 * stesso contesto del robot vuol dire che deve essere messo anche nella raspberry e altri eventuali dispositivi (che potrebbero
 * essere appesantiti dalla cosa) forse conviene fare un altro contesto in cui mettere la mind e il resouce model 
 * (GUARDA L'ARCHITETTURA ESAGONALE come spunto per risolvere questo problema)
 * (Per ora creo un constesto a se)
 * 
 * TODO valutare se avere due mind una per il virtual robot uno per il real robot. Questo perché i due ambienti potrebbero essere differenti
 * 
 * TODO valutare se aggiungere anche la parte di simulazione del robot fisico in fase di analisi (nel requisito uno è stato fatto)
 */
System robotRoomba
Event constraint   : constraint(CONSTRAINT, VALUE) // CONSTRAINT contiene il tipo di vincolo VALUE contiene il nuovo valore

Dispatch moveRobot : usercmd(CMD)
Dispatch execMoveRobot : usercmd(CMD)

pubSubServer "ws://localhost:1884"

Context ctxVirtualRobot ip [ host="localhost" port=8032 ] 
Context ctxResourceModel ip [ host="localhost" port=8030 ]
Context ctxRealRobot ip [ host="localhost" port=8031]

QActor virtualrobotexecutor context ctxVirtualRobot -pubsub {
	Plan init normal [
		javaRun it.unibo.utils.clientTcp.initClientConn("localhost","8999");
		delay 1000;
		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }"); // necessario per non farlo andare contro il sonar appena parte
		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }"); // necessario per non farlo andare contro il sonar appena parte
		println("Robot ready")
	]
	switchTo waitForCmd            
		 
   	Plan waitForCmd[  ]  
  	transition stopAfter 3600000   	//1h 
 		whenMsg execMoveRobot -> execMove  	  
 	finally repeatPlan 
 	
 	Plan execMove resumeLastPlan [
 		printCurrentMessage;
 		onMsg execMoveRobot : usercmd( robotgui(h(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'alarm' }");
    	onMsg execMoveRobot : usercmd( robotgui(w(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'moveForward', 'arg': -1 }");
     	onMsg execMoveRobot : usercmd( robotgui(s(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'moveBackward', 'arg': -1 }");
   		onMsg execMoveRobot : usercmd( robotgui(a(X)) )    -> 
  			javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnLeft', 'arg': 800 }");
    	onMsg execMoveRobot : usercmd( robotgui(d(X)) )    -> 
   			javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }")
 	] 
}

QActor realrobotexecutor context ctxRealRobot -pubsub {
	Plan init normal [
		javaOp "customExecute(\"python3 executor.py d\")";
		delay 5000;
		javaOp "customExecute(\"python3 executor.py a\")";
		delay 1000;
		println("Robot ready!")
	]
	switchTo waitForCmd
	
	Plan waitForCmd[  ]  
  	transition stopAfter 3600000   	//1h 
 		whenMsg execMoveRobot -> execMove  	  
 	finally repeatPlan
 	
 	Plan execMove resumeLastPlan [
 		printCurrentMessage;
 		onMsg execMoveRobot : usercmd( robotgui(h(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py h\")";
    	onMsg execMoveRobot : usercmd( robotgui(w(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py w\")";
     	onMsg execMoveRobot : usercmd( robotgui(s(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py s\")";
   		onMsg execMoveRobot : usercmd( robotgui(a(X)) )    -> 
  			javaOp "customExecute(\"python3 executor.py a\")";
    	onMsg execMoveRobot : usercmd( robotgui(d(X)) )    -> 
   			javaOp "customExecute(\"python3 executor.py d\")"
 	] 
 	
}
QActor mindrobot context ctxResourceModel -pubsub -g cyan {
	Rules {
		eval( let, X, X ). // lower equal than implementation using worldTheory.pl in src-more/it/unibo/mindrobot/
		eval( let, X, V ):- eval( lt, X , V ) .
		maxTemperature(25).
		currentTemperature(12).
		checkTemperature(cold):-
				maxTemperature(MAX), 
				currentTemperature(CURRENT), 
				eval(let, CURRENT, MAX), !.
		checkTemperature(hot):- 
				maxTemperature(MAX), 
				currentTemperature(CURRENT), 
				eval(gt, CURRENT, MAX), !.
	}
	
	Plan init normal [
		println("Mind robot ready")
	]
	switchTo waitPlan
	
	Plan waitPlan[  ]
	transition stopAfter 3600000   	//1h 
 		whenEvent constraint -> handleEvent,
 		whenMsg moveRobot -> handleMsg
 	finally repeatPlan 
 	
 	Plan handleEvent resumeLastPlan [
 		printCurrentEvent;
 		onEvent constraint : constraint(temp, V) -> ReplaceRule currentTemperature(X) with currentTemperature(V);
 		// dopo che cambio la temperatura se è troppo caldo devo stoppare il robot
 		// TODO valutare se è giusta o no come cosa
 		[ !? checkTemperature(hot)  ] 
 			publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) )
 			//publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) )	
 	]
 	
 	Plan handleMsg resumeLastPlan [
 		printCurrentMessage;
 		onMsg moveRobot : usercmd( robotgui(w(X)) ) ->{
 			[ !? checkTemperature(cold)  ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(w(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(w(low)) )
 				}		
 			else
 				 println("Too hot to work")
		};
		onMsg moveRobot : usercmd( robotgui(s(X)) ) ->{
 			[ !? checkTemperature(cold)  ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(s(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(s(low)) )
 				}		
 			else
 				 println("Too hot to work")
		};
		onMsg moveRobot : usercmd( robotgui(a(X)) ) ->{
 			[ !? checkTemperature(cold)  ]{
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(a(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(a(low)) )	
 				}	
 			else
 				 println("Too hot to work")
		};
		onMsg moveRobot : usercmd( robotgui(d(X)) ) ->{
 			[ !? checkTemperature(cold)  ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(d(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(d(low)) )	
 				}
 			else
 				 println("Too hot to work")
		};
 		onMsg moveRobot : usercmd( robotgui(h(X)) ) -> {
 			[ !? checkTemperature(cold)  ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) )	
 				
 				}	
 			else 
 				println("Too hot to work")
		}
 	]
}