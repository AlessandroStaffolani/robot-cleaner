/**
 * Dalla fase di analisi si è dedotto che il led è diverso a secondo dei contesti di utilizzo. In particolare:
 *  - nel caso del real robot è un led posto direttamente sulla raspberry
 *  - nel caso del virtual robot è una lampadina HUE posta in qualche posto nella casa (ricordando che questa lavora con il protocollo ZIGBEE)
 * In quest'ultimo cosa non avendo a disposizione una lampadina HUE si è deciso di simulare l'iterazione attraverso un server node, in modo 
 * tale che attraverso delle chiamate RESTFUL si può far blinkare la lampadina HUE il cui comportamento è simulato da una gui realizzata
 * in python.
 * 
 * Perché python e non java?
 * Analizzando il problema ci siamo resi conto che sarebbe stato più comodo usare python,nonostante avessimo un'interfaccia java pronta,
 * visto che per interagire con i vari pin della raspberry viene usato python.
 * 
 * Quindi utilizzeremo il server node non solo per la lampadina HUE ma anche per il led sulla raspberry in maniera tale che qualsiasi sia il 
 * robot in movimento sarà possibile accendere entrambi i led in un colpo solo e interagendo con un unico componente.
 * 
 * Sarà il server node a capire quale dei due led accendere in base al robot in movimento. Per capire quale robot sarà in movimento
 * si utilizzerà un RESOURCE MODEL.
 * Le seguenti risorse sono state modellate nel resource model come segue:
 *  - i robot sono stati modellati come executor ( si tengono in considerazione due modelli separati uno per il Real Robot uno per il Virtual Robot);
 *  - i led sono stati modellati come attuatori (si tengono in considerazioni due modelli separati uno per la lampadina HUE e uno per il led reale);
 * 	- il termometro e il clock sono stati modellati come sensori (come anche i vari sonar virtuali e reali)
 * 
 * 
 * In questa fase verranno rimossi:
 *  - il contesto, in quanto mi permetteva di eseguire il led in un nodo separato, cosa che ora posso fare ugualmente attraverso il server node
 *  - l'evento ctrlevent, in quanto verrà sostituito da una chiamata Restful al server
 * 
 * Cose che verranno aggiunte/aggiornate:
 * - Resource model in maniera tale da avere un modello di tutte le risorse ( sensori e attuatori )
 * - Aggiornate le rules attraverso l'utilizzo del resource model
 * 
 */
System robotRoomba
Event constraint   : constraint( CONSTRAINT, VALUE ) // CONSTRAINT contiene il tipo di vincolo VALUE contiene il nuovo valore
Event resourceChange : resourceChange( TYPE, CATEG, NAME, VALUE ) // Evento generato dal resource model quando c'è un cambiamento di stato

Dispatch moveRobot : usercmd(CMD)
Dispatch execMoveRobot : usercmd(CMD)

//pubSubServer "ws://localhost:1884" //virtual robot
pubSubServer "ws://192.168.137.1:1884" //real robot

Context ctxVirtualRobot ip [ host="localhost" port=8032 ] 
Context ctxMindRobot ip [ host="localhost" port=8030 ]
Context ctxRealRobot ip [ host="localhost" port=8031]

QActor virtualrobotexecutor context ctxVirtualRobot -pubsub {
	Plan init normal [
		javaRun it.unibo.utils.clientTcp.initClientConn("localhost","8999");
		delay 1000;
		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }"); // necessario per non farlo andare contro il sonar appena parte
		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }"); // necessario per non farlo andare contro il sonar appena parte
		println("Robot ready")
	]
	switchTo waitForCmd            
		 
   	Plan waitForCmd[  ]  
  	transition stopAfter 3600000   	//1h 
 		whenMsg execMoveRobot -> execMove  	  
 	finally repeatPlan 
 	
 	Plan execMove resumeLastPlan [
 		printCurrentMessage;
 		onMsg execMoveRobot : usercmd( robotgui(h(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'alarm' }");
    	onMsg execMoveRobot : usercmd( robotgui(w(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'moveForward', 'arg': -1 }");
     	onMsg execMoveRobot : usercmd( robotgui(s(X)) )    -> 
    		javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'moveBackward', 'arg': -1 }");
   		onMsg execMoveRobot : usercmd( robotgui(a(X)) )    -> 
  			javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnLeft', 'arg': 800 }");
    	onMsg execMoveRobot : usercmd( robotgui(d(X)) )    -> 
   			javaRun it.unibo.utils.clientTcp.sendMsg("{ 'type': 'turnRight', 'arg': 800 }")
 	] 
}

QActor realrobotexecutor context ctxRealRobot -pubsub {
	Plan init normal [
		javaOp "customExecute(\"python3 executor.py d\")";
		delay 5000;
		javaOp "customExecute(\"python3 executor.py a\")";
		delay 1000;
		println("Robot ready!")
	]
	switchTo waitForCmd
	
	Plan waitForCmd[  ]  
  	transition stopAfter 3600000   	//1h 
 		whenMsg execMoveRobot -> execMove  	  
 	finally repeatPlan
 	
 	Plan execMove resumeLastPlan [
 		printCurrentMessage;
 		onMsg execMoveRobot : usercmd( robotgui(h(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py h\")";
    	onMsg execMoveRobot : usercmd( robotgui(w(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py w\")";
     	onMsg execMoveRobot : usercmd( robotgui(s(X)) )    -> 
    		javaOp "customExecute(\"python3 executor.py s\")";
   		onMsg execMoveRobot : usercmd( robotgui(a(X)) )    -> 
  			javaOp "customExecute(\"python3 executor.py a\")";
    	onMsg execMoveRobot : usercmd( robotgui(d(X)) )    -> 
   			javaOp "customExecute(\"python3 executor.py d\")"
 	] 
 	
}
QActor mindrobot context ctxMindRobot -pubsub {	
	
	
	Plan init normal [
		demo consult("./resourceModel.pl");  //contains the models and related rules
		println("Mind robot ready")
		//javaRun it.unibo.utils.clientRest.sendPutBlink("true", "#00ff00", "http://localhost:5005/lamp/1/blink")
	]
	switchTo afterInit
	
	Plan afterInit [
		// Allo start della mind robot invio l'ora corrente su MQTT per la console
		javaRun it.unibo.utils.customDate.getHoursRM();
 		demo getModelItem( sensor, clock, clock1, R); //recupero il tempo (Attualmente è 8 per provare che funzioni)
 		[ ?? goalResult(getModelItem( sensor, clock, clock1, R)) ] publishEvent "unibo/qasys" -e constraint : constraint(clock1, R)
	]
	switchTo waitPlan
	
	Plan waitPlan[ ]
	transition stopAfter 3600000   	//1h 
 		whenEvent constraint -> handleEvent,
 		whenEvent resourceChange -> handleChange,
 		whenMsg moveRobot -> handleMsg
 	finally repeatPlan 
 	
 	Plan handleEvent resumeLastPlan [
 		printCurrentEvent;
 		/*TODO cambiare nome del constraint cityTemperature */
 		onEvent constraint : constraint(temp, V) -> demo changeModelItem(temperature, cityTemperature, V) //ReplaceRule currentTemperature(X) with currentTemperature(V);
// 		[ !? checkTemperature(hot)  ]{
// 			publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
// 			publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
// 			javaRun it.unibo.utils.clientRest.sendPutBlink("false", "#00ff00", "http://localhost:5005/lamp/1/blink")	
// 		}
 	]
 	
 	Plan handleChange resumeLastPlan [
 		printCurrentEvent;
 		onEvent resourceChange : resourceChange( sensor, CATEG, NAME, off ) -> {
 			publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
 			publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
 			demo changeModelItem(leds, NAME, off)
 		};
 		onEvent resourceChange : resourceChange( actuator, leds, NAME, off ) 
 			->{ 
 				/* Visto che l'emissione degli eventi di entrambi i led avviene quasi in contemporanea QActor non riesce a gestirli.
 				 * Quindi siamo costretti a fare a mano la chiamata rest al server per entrambi i led
 				 */
 				javaRun it.unibo.utils.clientRest.sendPutBlink("false", "#00ff00", "1");
 				javaRun it.unibo.utils.clientRest.sendPutBlink("false", "#00ff00", "2")
 			};
 		onEvent resourceChange : resourceChange( actuator, leds, NAME, on ) 
 			-> { 
 				javaRun it.unibo.utils.clientRest.sendPutBlink("true", "#00ff00", "1");
 				javaRun it.unibo.utils.clientRest.sendPutBlink("true", "#00ff00", "2")
 			}
 	]
 	
 	Plan handleMsg resumeLastPlan [
 		/* Ogni volta che si riceve un messaggio di movimento deve essere aggiornato il clock time
 		 * in modo tale da verificare se il movimento del robot è consentito o meno
 		 */
 		javaRun it.unibo.utils.customDate.getHoursRM();
 		/* Pubblico un messaggio realativo al tempo:
 		 * Attenzione devo far capire che il messaggio è per la console*/
 		demo getModelItem( sensor, clock, clock1, R); //recupero il tempo (Attualmente è 8 per provare che funzioni)
 		[ ?? goalResult(getModelItem( sensor, clock, clock1, R)) ] publishEvent "unibo/qasys" -e constraint : constraint(clock1, R);
 		
 		printCurrentMessage;
 		onMsg moveRobot : usercmd( robotgui(w(X)) ) ->{
 			[ !? model( type(executor, X), name(Y), value(true) )   ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(w(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(w(low)) );
 				/* Unica soluzione per evitare problemi nell'accensione del led reale è cambiare lo stato di uno solo per volta */
 				demo changeModelItem(leds, NAME, on)
 				
 				}		
 			else
 				 println("Too hot to work or out of time")
		};
		onMsg moveRobot : usercmd( robotgui(s(X)) ) ->{
 			[ !? model( type(executor, X), name(Y), value(true) )   ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(s(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(s(low)) );
 				demo changeModelItem(leds, NAME, on)
 				
 				}		
 			else
 				  println("Too hot to work or out of time")
		};
		onMsg moveRobot : usercmd( robotgui(a(X)) ) ->{
 			[ !? model( type(executor, X), name(Y), value(true) ) ]{
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(a(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(a(low)) )
 				/*demo changeModelItem(leds, NAME, on)
 				delay 500;
 				demo changeModelItem(leds, NAME, off)*/
 				
 				}	
 			else
 				  println("Too hot to work or out of time")
		};
		onMsg moveRobot : usercmd( robotgui(d(X)) ) ->{
 			[ !? model( type(executor, X), name(Y), value(true) ) ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(d(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(d(low)) )
 				/*demo changeModelItem(leds, NAME, on)
 				delay 500;
 				demo changeModelItem(leds, NAME, off)*/
 				
 				}
 			else
 				  println("Too hot to work or out of time")
		};
 		onMsg moveRobot : usercmd( robotgui(h(X)) ) -> {
 			[ !? model( type(executor, X), name(Y), value(true) ) ] {
 				publishMsg "unibo/qasys" for "virtualrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
 				publishMsg "unibo/qasys" for "realrobotexecutor" -m execMoveRobot : usercmd( robotgui(h(low)) );
 				demo changeModelItem(leds, NAME, off)
 				
 				}	
 			else 
 				 println("Too hot to work or out of time")
		}
 	]
}